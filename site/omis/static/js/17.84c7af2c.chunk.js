webpackJsonp([17],{41:function(n,t){n.exports="## What's GlobalStore?\n\nGlobalStore is Omi's built-in centralized data warehouse, which solves and provides the following problems and capabilities:\n\n* Component Tree Data Sharing\n* Data Change Updates Dependent Components on Demand\n\n![](https://github.com/Tencent/omi/raw/master/assets/store.jpg)\n\n## A piece of code is completely ready for GlobalStore\n\n```jsx\nimport { render, h } from 'omi'\n\nconst Counter = function (props, store, _, $) {\n  return <p>\n    Clicked: {$.data.count} times\n    {' '}\n    <button onClick={store.add}>+</button>\n    <button onClick={store.sub}>-</button>\n    <button onClick={store.addIfOdd}>\n      Add if odd\n      </button>\n    <button onClick={store.addAsync}>\n      Add async\n      </button>\n  </p>\n}\n\nCounter.use = ['count']\n\nCounter.store = (_, $) => {\n  return {\n    add() {\n      $.add()\n    },\n    sub() {\n      $.sub()\n    },\n    addIfOdd() {\n      if ($.data.count % 2 !== 0) {\n        $.add()\n      }\n    },\n    addAsync() {\n      setTimeout(() => $.add(), 1000)\n    }\n  }\n}\n\nrender(<Counter />, 'body', {\n  data: {\n    count: 0\n  },\n  sub() {\n    this.data.count--\n  },\n  add() {\n    this.data.count++\n  }\n})\n```\n\n* Declare a dependent path by `static use'.\n* `globalStore` injects all components from the root node through the third parameter of render.\n\nHere is a complicated example of `use'.\n\nData of globalStore:\n\n```json\n{\n  count: 0,\n  arr: ['china', 'tencent'],\n  motto: 'I love omi.',\n  userInfo: {\n    firstName: 'dnt',\n    lastName: 'zhang',\n    age: 18\n  }\n}\n```\n\nStatic use:\n\n```jsx\nstatic use = [\n  'count', //Direct string, accessible through this.use[0] \n  'arr[0]', //It also supports path, which is accessible through this.use[1]\n  //Support JSON\n  {\n    //Alias, accessible through this.use.reverseMotto\n    reverseMotto: [\n      'motto', //path\n      target => target.split('').reverse().join('')  //computed\n    ]\n  },\n  { name: 'arr[1]' }, //{ alias: path }\uff0caccessible through this.use.name\n  {\n    //alias\uff0caccessible through this.use.fullName\n    fullName: [\n      ['userInfo.firstName', 'userInfo.lastName'], //path array\n      (firstName, lastName) => firstName + lastName //computed\n    ]\n  },\n]\n```\n\nLet's look at the use of JSX:\n\n```jsx\n...\n...\n<div>\n  <button onClick={this.sub}>-</button>\n  <span>{this.use[0]}</span>\n  <button onClick={this.add}>+</button>\n  <div>\n    <span>{this.use[1]}</span>\n    <button onClick={this.rename}>rename</button>\n  </div>\n  <div>{this.use.reverseMotto}</div><button onClick={this.changeMotto}>change motto</button>\n  <div>{this.use.name}</div>\n  <div>{this.use[3]}</div>\n  <div>\n    {this.use.fullName}\n    <button onClick={this.changeFirstName}>change first name</button>\n  </div>\n</div>\n...\n...\n```\n\nWithout alias, you can also access it directly through `$.data.xxx'.\n\n### Path hit rule\n\n| Observe Path | path in static use   | update |\n| ---------- | ---------- | -------- |\n| abc        | abc        | true     |\n| abc[1]     | abc        | true     |\n| abc.a      | abc        | true     |\n| abc        | abc.a      | false   |\n| abc        | abc[1]     | false   |\n| abc        | abc[1].c   | false   |\n| abc.b      | abc.b      | true     |\n\nThe above can be updated by hitting only one condition!\n\nSummary: As long as the path of the injected component is equal to that declared in use or under one of the path sub-nodes declared in use, it will be updated!\n\n### Destructuring assignment\n\n```jsx\nconst Comp = function() {\n  const [menus, sideBarShow, lan] = this.using\n\n  return (\n    <div class={`list${sideBarShow ? ' show' : ''}`}>\n      {menus[lan].map((menu, index) => (\n        <my-list menu={menu} index={index} />\n      ))}\n    </div>\n  )\n}\n\nComp.use = [\n  'menus',\n  'sideBarShow',\n  'lan'\n]\n```\n\nHere is an example of using the ES2015+ Grammar `const [xx, xxx] = xxxx` for fast assignment.\n\n\n## Dynamic use\n\nIf you don't want the same components to have the same dependencies, you can use dynamic use:\n\n```js\nComp.store = _ => {\n  _.use = [\n    'a.b',\n    'c[1].d',\n    `e.f.${xxx}.d[${index}]`\n  ]\n}\n```\n\nVery flexible!\n"}});
//# sourceMappingURL=17.84c7af2c.chunk.js.map