{"version":3,"sources":["../static/js/8.b67630cb.chunk.js","docs/zh-cn/mps.md"],"names":["webpackJsonp","58","module","exports"],"mappings":"AAAAA,cAAc,IAERC,GACA,SAAUC,EAAQC,GCHxBD,EAAAC,QAAA","file":"static/js/8.b67630cb.chunk.js","sourcesContent":["webpackJsonp([8],{\n\n/***/ 58:\n/***/ (function(module, exports) {\n\nmodule.exports = \"## mps\\n\\n> 原生小程序插上 JSX 和 Less 的翅膀，**mp + sweet**\\n\\nmps 是什么？为什么需要 mps？先列举几个现状:\\n\\n* 目前小程序开发使用最多的技术依然是原生小程序\\n* 原生小程序的 API 在不断完善和进化中\\n* JSX 是表达能力和编程体验最好的 UI 表达式\\n* JSX 可以表达一切想表达的 UI 结构也就能够描述任意 WXML\\n\\n所以，就有了 mps，**mp + sweet**。 让开发者直接在原生小程序使用 JSX 写 WXML，用 Less 写 WXSS，实时编译，实时预览。\\n\\n![](https://github.com/Tencent/omi/raw/master/assets/mps.png)\\n\\n- JSX 代替 WXML 书写结构，精简高效\\n- 对原生小程序零入侵\\n- 支持 JS 和 TS\\n- 实时编译，实时预览\\n- 输出 WXML 自动美化\\n\\n## 效果预览\\n\\n![](https://github.com/Tencent/omi/raw/master/assets/mps.gif)\\n\\n## 立即开始\\n\\n```bash\\n$ npm i omi-cli -g              \\n$ omi init-mps my-app    \\n$ cd my-app        \\n$ npm start               \\n```\\n\\n接着把小程序目录设置为 my-app 目录便可以愉快地开始开发调试了！ \\n\\n> `npx omi-cli init-mps my-app` 也支持(npm v5.2.0+)\\n\\n生成的目录和官方的模板一致，只不过多了 JSX 文件，只需要修改 JSX 文件就会实时修改 WXML。\\n\\n也支持 typescript:\\n\\n```bash           \\n$ omi init-mps-ts my-app             \\n```\\n\\n其他命令一样。\\n\\n> `npx omi-cli init-mps-ts my-app` 也支持(npm v5.2.0+)\\n\\n## JSX vs WXML\\n\\n这里是一个真实的案例说明 JSX 的精巧高效的表达能力:\\n\\n编译前的 JSX:\\n\\n```jsx\\n<view class='pre language-jsx'>\\n  <view class='code'>\\n    {tks.map(tk => {\\n      return tk.type === 'tag' ? <text class={'token ' + tk.type}>{\\n        tk.content.map(stk => {\\n          return stk.deep ? stk.content.map(sstk => {\\n            return <text class={'token ' + sstk.type}>{sstk.content || sstk}</text>\\n          }) : <text class={'token ' + stk.type}>{stk.content || stk}</text>\\n        })}</text> : <text class={'token ' + tk.type}>{tk.content || tk}</text>\\n    })}\\n  </view>\\n</view>\\n```\\n\\n编译后 WXML:\\n\\n```jsx\\n<view class=\\\"pre language-jsx\\\">\\n  <view class=\\\"code\\\">\\n    <block wx:for=\\\"{{tks}}\\\" wx:for-item=\\\"tk\\\" wx:for-index=\\\"_anonIdx4\\\">\\n      <block wx:if=\\\"{{tk.type === 'tag'}}\\\"\\n        ><text class=\\\"{{'token ' + tk.type}}\\\"\\n          ><block\\n            wx:for=\\\"{{tk.content}}\\\"\\n            wx:for-item=\\\"stk\\\"\\n            wx:for-index=\\\"_anonIdx2\\\"\\n            ><block wx:if=\\\"{{stk.deep}}\\\"\\n              ><text\\n                class=\\\"{{'token ' + sstk.type}}\\\"\\n                wx:for=\\\"{{stk.content}}\\\"\\n                wx:for-item=\\\"sstk\\\"\\n                wx:for-index=\\\"_anonIdx3\\\"\\n                >{{sstk.content || sstk}}</text\\n              >\\n            </block>\\n            <block wx:else\\n              ><text class=\\\"{{'token ' + stk.type}}\\\"\\n                >{{stk.content || stk}}</text\\n              >\\n            </block>\\n          </block>\\n        </text>\\n      </block>\\n      <block wx:else\\n        ><text class=\\\"{{'token ' + tk.type}}\\\">{{tk.content || tk}}</text>\\n      </block>\\n    </block>\\n  </view>\\n</view>\\n```\\n\\n## 老项目使用 mps\\n\\n拷贝以下文件到小程序根目录:\\n\\n* _scripts 目录所有文件\\n* package.json\\n* gulpfile.js\\n\\n设置 project.config.json 里的 packOptions.ignore 忽略以上的文件，然后:\\n\\n``` bash\\n$ npm install\\n$ npm start\\n```\\n\\n## mps 约定\\n\\n公共的 less 文件必须放在 common-less 目录，@import 使用的时候不需要写路径。\\n\\n## 推荐搭配\\n\\n既然用了原生小程序的方案，所有可以轻松使用 mps + [omix](https://github.com/Tencent/omi/tree/master/packages/omix) 搭配一起使用。\\n\\n欢迎使用 mps 大幅提高开发效率，Have fun!\\n\"\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/8.b67630cb.chunk.js","module.exports = \"## mps\\n\\n> 原生小程序插上 JSX 和 Less 的翅膀，**mp + sweet**\\n\\nmps 是什么？为什么需要 mps？先列举几个现状:\\n\\n* 目前小程序开发使用最多的技术依然是原生小程序\\n* 原生小程序的 API 在不断完善和进化中\\n* JSX 是表达能力和编程体验最好的 UI 表达式\\n* JSX 可以表达一切想表达的 UI 结构也就能够描述任意 WXML\\n\\n所以，就有了 mps，**mp + sweet**。 让开发者直接在原生小程序使用 JSX 写 WXML，用 Less 写 WXSS，实时编译，实时预览。\\n\\n![](https://github.com/Tencent/omi/raw/master/assets/mps.png)\\n\\n- JSX 代替 WXML 书写结构，精简高效\\n- 对原生小程序零入侵\\n- 支持 JS 和 TS\\n- 实时编译，实时预览\\n- 输出 WXML 自动美化\\n\\n## 效果预览\\n\\n![](https://github.com/Tencent/omi/raw/master/assets/mps.gif)\\n\\n## 立即开始\\n\\n```bash\\n$ npm i omi-cli -g              \\n$ omi init-mps my-app    \\n$ cd my-app        \\n$ npm start               \\n```\\n\\n接着把小程序目录设置为 my-app 目录便可以愉快地开始开发调试了！ \\n\\n> `npx omi-cli init-mps my-app` 也支持(npm v5.2.0+)\\n\\n生成的目录和官方的模板一致，只不过多了 JSX 文件，只需要修改 JSX 文件就会实时修改 WXML。\\n\\n也支持 typescript:\\n\\n```bash           \\n$ omi init-mps-ts my-app             \\n```\\n\\n其他命令一样。\\n\\n> `npx omi-cli init-mps-ts my-app` 也支持(npm v5.2.0+)\\n\\n## JSX vs WXML\\n\\n这里是一个真实的案例说明 JSX 的精巧高效的表达能力:\\n\\n编译前的 JSX:\\n\\n```jsx\\n<view class='pre language-jsx'>\\n  <view class='code'>\\n    {tks.map(tk => {\\n      return tk.type === 'tag' ? <text class={'token ' + tk.type}>{\\n        tk.content.map(stk => {\\n          return stk.deep ? stk.content.map(sstk => {\\n            return <text class={'token ' + sstk.type}>{sstk.content || sstk}</text>\\n          }) : <text class={'token ' + stk.type}>{stk.content || stk}</text>\\n        })}</text> : <text class={'token ' + tk.type}>{tk.content || tk}</text>\\n    })}\\n  </view>\\n</view>\\n```\\n\\n编译后 WXML:\\n\\n```jsx\\n<view class=\\\"pre language-jsx\\\">\\n  <view class=\\\"code\\\">\\n    <block wx:for=\\\"{{tks}}\\\" wx:for-item=\\\"tk\\\" wx:for-index=\\\"_anonIdx4\\\">\\n      <block wx:if=\\\"{{tk.type === 'tag'}}\\\"\\n        ><text class=\\\"{{'token ' + tk.type}}\\\"\\n          ><block\\n            wx:for=\\\"{{tk.content}}\\\"\\n            wx:for-item=\\\"stk\\\"\\n            wx:for-index=\\\"_anonIdx2\\\"\\n            ><block wx:if=\\\"{{stk.deep}}\\\"\\n              ><text\\n                class=\\\"{{'token ' + sstk.type}}\\\"\\n                wx:for=\\\"{{stk.content}}\\\"\\n                wx:for-item=\\\"sstk\\\"\\n                wx:for-index=\\\"_anonIdx3\\\"\\n                >{{sstk.content || sstk}}</text\\n              >\\n            </block>\\n            <block wx:else\\n              ><text class=\\\"{{'token ' + stk.type}}\\\"\\n                >{{stk.content || stk}}</text\\n              >\\n            </block>\\n          </block>\\n        </text>\\n      </block>\\n      <block wx:else\\n        ><text class=\\\"{{'token ' + tk.type}}\\\">{{tk.content || tk}}</text>\\n      </block>\\n    </block>\\n  </view>\\n</view>\\n```\\n\\n## 老项目使用 mps\\n\\n拷贝以下文件到小程序根目录:\\n\\n* _scripts 目录所有文件\\n* package.json\\n* gulpfile.js\\n\\n设置 project.config.json 里的 packOptions.ignore 忽略以上的文件，然后:\\n\\n``` bash\\n$ npm install\\n$ npm start\\n```\\n\\n## mps 约定\\n\\n公共的 less 文件必须放在 common-less 目录，@import 使用的时候不需要写路径。\\n\\n## 推荐搭配\\n\\n既然用了原生小程序的方案，所有可以轻松使用 mps + [omix](https://github.com/Tencent/omi/tree/master/packages/omix) 搭配一起使用。\\n\\n欢迎使用 mps 大幅提高开发效率，Have fun!\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/docs/zh-cn/mps.md\n// module id = 58\n// module chunks = 8"],"sourceRoot":""}