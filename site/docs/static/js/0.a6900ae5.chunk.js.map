{"version":3,"sources":["../static/js/0.a6900ae5.chunk.js","docs/zh-cn/store.md"],"names":["webpackJsonp","42","module","exports"],"mappings":"AAAAA,cAAc,IAERC,GACA,SAAUC,EAAQC,GCHxBD,EAAAC,QAAA","file":"static/js/0.a6900ae5.chunk.js","sourcesContent":["webpackJsonp([0],{\n\n/***/ 42:\n/***/ (function(module, exports) {\n\nmodule.exports = \"## Store 是什么？\\n\\nStore 是 Omi 内置的中心化数据仓库，他解决和提供了下面问题和能力：\\n\\n* 组件树数据共享\\n* 数据变更按需更新依赖的组件\\n\\n![](https://github.com/Tencent/omi/raw/master/assets/store.jpg)\\n\\n## 一段代码完全上手 Store\\n\\n```jsx\\nimport { render, WeElement, define } from '../../src/omi'\\n\\ndefine('my-counter', class extends WeElement {\\n  static use = [\\n    { count: 'count' }\\n  ]\\n\\n  add = () => this.store.add()\\n  sub = () => this.store.sub()\\n\\n  addIfOdd = () => {\\n    if (this.use.count % 2 !== 0) {\\n      this.store.add()\\n    }\\n  }\\n\\n  addAsync = () => {\\n    setTimeout(() => this.store.add(), 1000)\\n  }\\n\\n  render() {\\n    return (\\n      <p>\\n        Clicked: {this.use.count} times\\n        {' '}\\n        <button onClick={this.add}>+</button>\\n        {' '}\\n        <button onClick={this.sub}>-</button>\\n        {' '}\\n        <button onClick={this.addIfOdd}>\\n          Add if odd\\n        </button>\\n        {' '}\\n        <button onClick={this.addAsync}>\\n          Add async\\n        </button>\\n      </p>\\n    )\\n  }\\n})\\n\\nrender(<my-counter />, 'body', {\\n  data: {\\n    count: 0\\n  },\\n  sub() {\\n    this.data.count--\\n  },\\n  add() {\\n    this.data.count++\\n  },\\n})\\n```\\n\\n* 通过 `static use` 声明依赖的 path\\n* `store` 通过 render 的第三个参数从根节点注入到所有组件。\\n\\n下面举一个复杂的 `use` 例子：\\n\\n```jsx\\nstatic use = [\\n  'count', //直接字符串，JSX 里可通过 this.use[0] 访问\\n  'arr[0]', //也支持 path，JSX 里可通过 this.use[1] 访问\\n  //支持 json\\n  {\\n    //alias，JSX 里可通过 this.use.reverseMotto 访问\\n    reverseMotto: [\\n      'motto', //path\\n      target => target.split('').reverse().join('')  //computed\\n    ]\\n  },\\n  { name: 'arr[1]' }, //{ alias: path }，JSX 里可通过 this.use.name 访问\\n  {\\n    //alias，JSX 里可通过 this.use.fullName 访问\\n    fullName: [\\n      ['userInfo.firstName', 'userInfo.lastName'], //path array\\n      (firstName, lastName) => firstName + lastName //computed\\n    ]\\n  },\\n]\\n```\\n\\n下面看看 JSX 中使用:\\n\\n```jsx\\n...\\n...\\nrender() {\\n  return (\\n    <div>\\n      <button onClick={this.sub}>-</button>\\n      <span>{this.use[0]}</span>\\n      <button onClick={this.add}>+</button>\\n      <div>\\n        <span>{this.use[1]}</span>\\n        <button onClick={this.rename}>rename</button>\\n      </div>\\n      <div>{this.use.reverseMotto}</div><button onClick={this.changeMotto}>change motto</button>\\n      <div>{this.use.name}</div>\\n      <div>{this.use[3]}</div>\\n      <div>\\n        {this.use.fullName}\\n        <button onClick={this.changeFirstName}>change first name</button>\\n      </div>\\n    </div>\\n  )\\n}\\n...\\n...\\n```\\n\\n如果不带有 alias ，你也可以直接通过 `this.store.data.xxx` 访问。\"\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/0.a6900ae5.chunk.js","module.exports = \"## Store 是什么？\\n\\nStore 是 Omi 内置的中心化数据仓库，他解决和提供了下面问题和能力：\\n\\n* 组件树数据共享\\n* 数据变更按需更新依赖的组件\\n\\n![](https://github.com/Tencent/omi/raw/master/assets/store.jpg)\\n\\n## 一段代码完全上手 Store\\n\\n```jsx\\nimport { render, WeElement, define } from '../../src/omi'\\n\\ndefine('my-counter', class extends WeElement {\\n  static use = [\\n    { count: 'count' }\\n  ]\\n\\n  add = () => this.store.add()\\n  sub = () => this.store.sub()\\n\\n  addIfOdd = () => {\\n    if (this.use.count % 2 !== 0) {\\n      this.store.add()\\n    }\\n  }\\n\\n  addAsync = () => {\\n    setTimeout(() => this.store.add(), 1000)\\n  }\\n\\n  render() {\\n    return (\\n      <p>\\n        Clicked: {this.use.count} times\\n        {' '}\\n        <button onClick={this.add}>+</button>\\n        {' '}\\n        <button onClick={this.sub}>-</button>\\n        {' '}\\n        <button onClick={this.addIfOdd}>\\n          Add if odd\\n        </button>\\n        {' '}\\n        <button onClick={this.addAsync}>\\n          Add async\\n        </button>\\n      </p>\\n    )\\n  }\\n})\\n\\nrender(<my-counter />, 'body', {\\n  data: {\\n    count: 0\\n  },\\n  sub() {\\n    this.data.count--\\n  },\\n  add() {\\n    this.data.count++\\n  },\\n})\\n```\\n\\n* 通过 `static use` 声明依赖的 path\\n* `store` 通过 render 的第三个参数从根节点注入到所有组件。\\n\\n下面举一个复杂的 `use` 例子：\\n\\n```jsx\\nstatic use = [\\n  'count', //直接字符串，JSX 里可通过 this.use[0] 访问\\n  'arr[0]', //也支持 path，JSX 里可通过 this.use[1] 访问\\n  //支持 json\\n  {\\n    //alias，JSX 里可通过 this.use.reverseMotto 访问\\n    reverseMotto: [\\n      'motto', //path\\n      target => target.split('').reverse().join('')  //computed\\n    ]\\n  },\\n  { name: 'arr[1]' }, //{ alias: path }，JSX 里可通过 this.use.name 访问\\n  {\\n    //alias，JSX 里可通过 this.use.fullName 访问\\n    fullName: [\\n      ['userInfo.firstName', 'userInfo.lastName'], //path array\\n      (firstName, lastName) => firstName + lastName //computed\\n    ]\\n  },\\n]\\n```\\n\\n下面看看 JSX 中使用:\\n\\n```jsx\\n...\\n...\\nrender() {\\n  return (\\n    <div>\\n      <button onClick={this.sub}>-</button>\\n      <span>{this.use[0]}</span>\\n      <button onClick={this.add}>+</button>\\n      <div>\\n        <span>{this.use[1]}</span>\\n        <button onClick={this.rename}>rename</button>\\n      </div>\\n      <div>{this.use.reverseMotto}</div><button onClick={this.changeMotto}>change motto</button>\\n      <div>{this.use.name}</div>\\n      <div>{this.use[3]}</div>\\n      <div>\\n        {this.use.fullName}\\n        <button onClick={this.changeFirstName}>change first name</button>\\n      </div>\\n    </div>\\n  )\\n}\\n...\\n...\\n```\\n\\n如果不带有 alias ，你也可以直接通过 `this.store.data.xxx` 访问。\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/docs/zh-cn/store.md\n// module id = 42\n// module chunks = 0"],"sourceRoot":""}